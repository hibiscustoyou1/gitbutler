/* auto-generated by NAPI-RS */
/* eslint-disable */
/** r" napi function - strongly typed params, serde_json::Value output, automatic error conversion. */
export declare function listProjectsNapi(openedProjects: Array<ProjectId>): Array<ProjectForFrontend>

/** r" napi function - strongly typed params, serde_json::Value output, automatic error conversion. */
export declare function stackDetailsNapi(projectId: string, stackId: StackId | null): StackDetails

/** r" napi function - strongly typed params, serde_json::Value output, automatic error conversion. */
export declare function stacksNapi(projectId: string, filter: StacksFilter | null): Array<StackEntry>

// Auto-generated by but-ts. Do not edit manually.
// Generated from JSON schemas registered by #[but_api] functions.

/**
 * API-specific project type that can be enriched with computed/derived data
 * while preserving the original project structure for persistence.
 */
export type ProjectForFrontend = {
  api?: ApiProject | null;
  description?: string | null;
  /** Force push protection uses safer force push flags instead of doing straight force pushes */
  force_push_protection?: boolean;
  forge_override?: string | null;
  /** Path to the forge review template, if set in git configuration. */
  forge_review_template_path?: string | null;
  /** Gerrit mode enabled for this project, derived from git configuration */
  gerrit_mode?: boolean;
  /**
   * The storage location of the Git repository itself.
   * This is the only value we need to access everything related to the Git repository.
   */
  git_dir?: string;
  gitbutler_code_push_state?: CodePushState | null;
  gitbutler_data_last_fetch?: FetchResult | null;
  id: string;
  /** Tell if the project is known to be open in a Window in the frontend. */
  is_open: boolean;
  /**
   * if ok_with_force_push is true, we'll not try to avoid force pushing
   * for example, when updating base branch
   */
  ok_with_force_push?: boolean;
  omit_certificate_check?: boolean | null;
  /** The worktree directory of the project's repository. */
  path: string;
  preferred_forge_user?: ForgeUser | null;
  preferred_key?: AuthKey;
  project_data_last_fetch?: FetchResult | null;
  snapshot_lines_threshold?: number | null;
  title: string;
};

export type ProjectId = string;

/** Information about the current state of a stack */
export type StackDetails = {
  /** The details about the contained branches */
  branchDetails: Array<BranchDetails>;
  /** This is the name of the top-most branch, provided by the API for convenience */
  derivedName: string;
  /** Whether the stack is conflicted. */
  isConflicted: boolean;
  /** The pushable status for the stack */
  pushStatus: PushStatus;
};

/**
 * Represents a lightweight version of a [`Stack`] for listing.
 * NOTE: this is a UI type mostly because it's still modeled after the legacy stack with StackId, something that doesn't exist anymore.
 */
export type StackEntry = {
  /**
   * The list of the branch information that are part of the stack.
   * The list is never empty.
   * The first entry in the list is always the most recent branch on top the stack.
   */
  heads: Array<StackHeadInfo>;
  /** The ID of the stack. */
  id: string | null;
  /** If `true`, then any head in this stack is checked directly so `HEAD` points to it, and this is only ever `true` for a single stack. */
  isCheckedOut: boolean;
  /** The zero-based index for sorting stacks. */
  order?: number | null;
  /** The tip of the top-most branch, i.e., the most recent commit that would become the parent of new commits of the topmost stack branch. */
  tip: string;
};

export type StackId = string;

/** A filter for the list of stacks. */
export type StacksFilter = "All" | "InWorkspace" | "Unapplied";

export type ApiProject = {
  /** The "project" git URL */
  code_git_url?: string | null;
  created_at: string;
  description?: string | null;
  /** The "gitbuler data, i.e. oplog" URL */
  git_url: string;
  name: string;
  repository_id: string;
  reviews?: boolean;
  /** Determines if the project Operations log will be synched with the GitButHub */
  sync: boolean;
  /** Determines if the project code will be synched with the GitButHub */
  sync_code?: boolean;
  updated_at: string;
};

export type AuthKey = "gitCredentialsHelper" | "systemExecutable" | {
  local: {
    private_key_path: string;
  };
};

/** Represents the author of a commit. */
export type Author = {
  /** The email from the git commit signature */
  email: string;
  /** A URL to a gravatar image for the email from the commit signature */
  gravatarUrl: string;
  /** The name from the git commit signature */
  name: string;
};

/** Information about the current state of a branch. */
export type BranchDetails = {
  /** All authors of the commits in the branch. */
  authors: Array<Author>;
  /**
   * This is the base commit from the perspective of this branch.
   * If the branch is part of a stack and is on top of another branch, this is the head of the branch below it.
   * If this branch is at the bottom of the stack, this is the merge base of the stack.
   */
  baseCommit: string;
  /** The commits contained in the branch, excluding the upstream commits. */
  commits: Array<Commit>;
  /** Whether the branch is conflicted. */
  isConflicted: boolean;
  /** Whether it's representing a remote head */
  isRemoteHead: boolean;
  /** Last time, the branch was updated in Epoch milliseconds. */
  lastUpdatedAt?: number | null;
  /**
   * The id of the linked worktree that has the reference of `name` checked out.
   * Note that we don't list the main worktree here.
   */
  linkedWorktreeId: string | null;
  /** The name of the branch. This is the "given name" IE, just `foo` out of `refs/heads/foo` */
  name: string;
  /** The pull(merge) request associated with the branch, or None if no such entity has not been created. */
  prNumber?: number | null;
  /** The pushable status for the branch. */
  pushStatus: PushStatus;
  /** The full reference of the branch */
  reference: string;
  /** Upstream reference, e.g. `refs/remotes/origin/base-branch-improvements` */
  remoteTrackingBranch: string | null;
  /** A unique identifier for the GitButler review associated with the branch, if any. */
  reviewId?: string | null;
  /**
   * This is the last commit in the branch, aka the tip of the branch.
   * If this is the only branch in the stack or the top-most branch, this is the tip of the stack.
   */
  tip: string;
  /** The commits that are only at the remote. */
  upstreamCommits: Array<UpstreamCommit>;
};

export type CodePushState = {
  id: string;
  timestamp: SystemTime;
};

/** Commit that is a part of a [`StackBranch`](gitbutler_stack::StackBranch) and, as such, containing state derived in relation to the specific branch. */
export type Commit = {
  /** The author of the commit. */
  author: Author;
  /** Commit creation time in Epoch milliseconds. */
  createdAt: number;
  /**
   * Optional URL to the Gerrit review for this commit, if applicable.
   * Only populated if Gerrit mode is enabled and the commit has an associated review.
   */
  gerritReviewUrl?: string | null;
  /**
   * Whether the commit is in a conflicted state.
   * The Conflicted state of a commit is a GitButler concept.
   * GitButler will perform rebasing/reordering etc without interruptions and flag commits as conflicted if needed.
   * Conflicts are resolved via the Edit Mode mechanism.
   */
  hasConflicts: boolean;
  /** The OID of the commit. */
  id: string;
  /** The message of the commit. */
  message: string;
  /** The parent OIDs of the commit. */
  parentIds: Array<string>;
  /**
   * Represents whether the commit is considered integrated, local only,
   * or local and remote with respect to the branch it belongs to.
   * Note that remote only commits in the context of a branch are expressed with the [`UpstreamCommit`] struct instead of this.
   */
  state: CommitState;
};

/** Represents the state a commit could be in. */
export type CommitState = {
  type: "LocalOnly";
} | {
  subject: string;
  type: "LocalAndRemote";
} | {
  type: "Integrated";
};

export type FetchResult = {
  fetched: {
    timestamp: SystemTime;
  };
} | {
  error: {
    error: string;
    timestamp: SystemTime;
  };
};

export type ForgeUser = {
  details: GithubAccountIdentifier;
  provider: "github";
} | {
  details: GitlabAccountIdentifier;
  provider: "gitlab";
};

export type GithubAccountIdentifier = {
  info: {
    username: string;
  };
  type: "oAuthUsername";
} | {
  info: {
    username: string;
  };
  type: "patUsername";
} | {
  info: {
    host: string;
    username: string;
  };
  type: "enterprise";
};

export type GitlabAccountIdentifier = {
  info: {
    username: string;
  };
  type: "patUsername";
} | {
  info: {
    host: string;
    username: string;
  };
  type: "selfHosted";
};

/** Represents the pushable status for the current stack. */
export type PushStatus = "nothingToPush" | "unpushedCommits" | "unpushedCommitsRequiringForce" | "completelyUnpushed" | "integrated";

/** The information about the branch inside a stack */
export type StackHeadInfo = {
  /**
   * If `true`, then this head is checked directly so `HEAD` points to it, and this is only ever `true` for a single head.
   * This is `false` if the worktree is checked out.
   */
  isCheckedOut: boolean;
  /** The name of the branch. */
  name: string;
  /** The associated forge review with this branch, e.g. GitHub PRs or GitLab MRs */
  reviewId?: number | null;
  /** The tip of the branch. */
  tip: string;
};

export type SystemTime = {
  nanos_since_epoch: number;
  secs_since_epoch: number;
};

/**
 * Commit that is only at the remote.
 * Unlike the `Commit` struct, there is no knowledge of GitButler concepts like conflicted state etc.
 */
export type UpstreamCommit = {
  /** The author of the commit. */
  author: Author;
  /** Commit creation time in Epoch milliseconds. */
  createdAt: number;
  /** The OID of the commit. */
  id: string;
  /** The message of the commit. */
  message: string;
};

